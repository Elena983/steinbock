---
title: "bodenmiller"
output: html_notebook
---

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install(c("rmarkdown", "bookdown", "pheatmap", "viridis", "zoo", 
                       "devtools", "testthat", "tiff", "distill", "ggrepel", 
                       "patchwork", "mclust", "RColorBrewer", "uwot", "Rtsne", 
                       "harmony", "Seurat", "SeuratObject", "cowplot", "kohonen", 
                       "caret", "randomForest", "ggridges", "cowplot", 
                       "gridGraphics", "scales", "tiff", "harmony", "Matrix", 
                       "CATALYST", "scuttle", "scater", "dittoSeq", 
                       "tidyverse", "BiocStyle", "batchelor", "bluster", "scran", 
                       "lisaClust", "spicyR", "iSEE", "imcRtools", "cytomapper",
                       "imcdatasets", "cytoviewer"))

# Github dependencies
devtools::install_github("i-cyto/Rphenograph")

##reading the data

library(imcRtools)
library(cytomapper)

#steinbock generated data
spe <- read_steinbock("/media/Lena/steinbock_all")
spe

#The summarized mean intensities per channel and cell 
counts(spe)[1:5,1:5]

#Metadata associated to individual cells
head(colData(spe))

#spatial locations of all cells
head(spatialCoords(spe))

#Cell-cell interactions (cells in close spatial proximity) are represented as “edge list”
colPair(spe, "neighborhood")

#metadata regarding the channels from panel.csv
head(rowData(spe))

#---------------------------
##Single-cell processing

#set the colnames of the object to generate unique identifiers per cell
colnames(spe) <- paste0(spe$sample_id, "_", spe$ObjectNumber)

library(tidyverse)
spe$patient_id <- str_extract(spe$sample_id, "patient[1-3]")
unique(spe$patient_id)

##Transform counts

#The distribution of expression counts across cells is often observed 
#to be skewed towards the right side 
#meaning lots of cells display low counts and few cells have high counts

#CODEX cofactor appr. = 5
library(dittoSeq)
dittoRidgePlot(spe, var = "CD3", group.by = "patient_id", assay = "counts") +
    ggtitle("CD3 - before transformation")

assay(spe, "exprs") <- asinh(counts(spe)/5)

dittoRidgePlot(spe, var = "CD3", group.by = "patient_id", assay = "exprs") +
    ggtitle("CD3 - after transformation")

#deselect the nuclear markers used for segmentation or markers with low signal-to-noise ratio
rowData(spe)$use_channel <- !grepl("DAPI|Vimentin|Ki-67|PD-1|PD-L1|s100|CD16", rownames(spe))
rowData(spe)$use_channel

#Define color schemes
library(RColorBrewer)
color_vectors <- list()

patient_id <- setNames(brewer.pal(length(unique(spe$patient_id)), name = "Set1"), 
                unique(spe$patient_id))

color_vectors$patient_id <- patient_id
metadata(spe)$color_vectors <- color_vectors

#-----------------------------------------
##Read in images

images <- loadImages("/media/Lena/steinbock_all/img")

masks <- loadImages("/media/Lena/steinbock_all/masks/", as.is = TRUE)

# set the channelNames for easy visualization
channelNames(images) <- rownames(spe)
images

# add additional metadata to the elementMetadata slot of the CytoImageList objects via mcols 
all.equal(names(images), names(masks))
# Extract patient id from image name
patient_id <- str_extract(names(images), "patient[1-3]")

## Store patient and image level information in elementMetadata
mcols(images) <- mcols(masks) <- DataFrame(sample_id = names(images),
                                           patient_id = patient_id)

#-----------------------------------------
#Generate single-cell data from images

cytomapper_sce <- measureObjects(masks, image = images, img_id = "sample_id")
cytomapper_sce

#----------------------------------------
#Save objects

saveRDS(spe, "/media/Lena/steinbock_all/spe.rds")
saveRDS(images, "/media/Lena/steinbock_all/images.rds")
saveRDS(masks, "/media/Lena/steinbock_all/masks.rds")

#-----------------------------------------
#Image and cell-level quality control

#read in the data
images <- readRDS("/media/Lena/steinbock_all/images.rds")
masks <- readRDS("/media/Lena/steinbock_all/masks.rds")
spe <- readRDS("/media/Lena/steinbock_all/spe.rds")

#Segmentation quality control

library(cytomapper)
set.seed(20220118)
img_ids <- sample(seq_along(images), 3)

# Normalize and clip images
cur_images <- images[img_ids]
cur_images <- cytomapper::normalize(cur_images, separateImages = TRUE)
cur_images <- cytomapper::normalize(cur_images, inputRange = c(0, 0.2))

grid::current.viewport()
plot <- plotPixels(cur_images,
           mask = masks[img_ids],
           img_id = "sample_id",
           missing_colour = "white",
           colour_by = c("CD4", "CD20", "CK", "aSMA", "DAPI"),
           colour = list(CD4 = c("black", "yellow"),
                         CD20 = c("black", "red"),
                         CK = c("black", "green"),
                         aSMA = c("black", "cyan"),
                         DAPI = c("black", "blue")),
           image_title = NULL,
           legend = list(colour_by.title.cex = 0.7,
                         colour_by.labels.cex = 0.7))
plot

#An easier and interactive way of observing segmentation quality
library(cytoviewer)

app <- cytoviewer(image = images, 
                  mask = masks, 
                  object = spe,
                  cell_id = "ObjectNumber", 
                  img_id = "sample_id")

if (interactive()) {
    shiny::runApp(app)
}

#heatmap for segmentation quality
library(dittoSeq)
library(viridis)
cur_cells <- sample(seq_len(ncol(spe)), 2000)

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", 
             cluster_cols = TRUE, 
             scale = "none",
             heatmap.colors = viridis(100))

#Signal intensity
library(tidyverse)
library(ggrepel)
library(EBImage)

cur_snr <- lapply(names(images), function(x){
    img <- images[[x]]
    mat <- apply(img, 3, function(ch){
        # Otsu threshold
        thres <- otsu(ch, range = c(min(ch), max(ch)), levels = 65536)
        # Signal-to-noise ratio
        snr <- mean(ch[ch > thres]) / mean(ch[ch <= thres])
        # Signal intensity
        ps <- mean(ch[ch > thres])
        
        return(c(snr = snr, ps = ps))
    })
    t(mat) %>% as.data.frame() %>% 
        mutate(image = x,
               marker = colnames(mat)) %>% 
        pivot_longer(cols = c(snr, ps))
})

cur_snr <- do.call(rbind, cur_snr)

cur_snr %>% 
    group_by(marker, name) %>%
    summarize(log_mean = log2(mean(value))) %>%
    pivot_wider(names_from = name, values_from = log_mean) %>%
    ggplot() +
    geom_point(aes(ps, snr)) +
    geom_label_repel(aes(ps, snr, label = marker)) +
    theme_minimal(base_size = 15) + ylab("Signal-to-noise ratio [log2]") +
    xlab("Signal intensity [log2]")
    
#remove markers that have a positive signal of below 2 per image
cur_snr <- cur_snr %>% 
    pivot_wider(names_from = name, values_from = value) %>%
    filter(ps > 2) %>%
    pivot_longer(cols = c(snr, ps))

cur_snr %>% 
    group_by(marker, name) %>%
    summarize(log_mean = log2(mean(value))) %>%
    pivot_wider(names_from = name, values_from = log_mean) %>%
    ggplot() +
    geom_point(aes(ps, snr)) +
    geom_label_repel(aes(ps, snr, label = marker)) +
    theme_minimal(base_size = 15) + ylab("Signal-to-noise ratio [log2]") +
    xlab("Signal intensity [log2]")

#quality indicator is the image area covered by cells
cell_density <- colData(spe) %>%
    as.data.frame() %>%
    group_by(sample_id) %>%
    # Compute the number of pixels covered by cells and 
    # the total number of pixels
    summarize(cell_area = sum(area),
              no_pixels = mean(width_px) * mean(height_px)) %>%
    # Divide the total number of pixels 
    # by the number of pixels covered by cells
    mutate(covered_area = cell_area / no_pixels)

# Visualize the image area covered by cells per image
ggplot(cell_density) +
        geom_point(aes(reorder(sample_id,covered_area), covered_area)) + 
        theme_minimal(base_size = 15) +
        theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 15)) +
        ylim(c(0, 1)) +
        ylab("% covered area") + xlab("")
        
#see the images with low cell coverage
#less dense tissue structure but overall the images are intact and appear to be segmented correctly.
cur_images <- images[c("patient2")]
cur_images <- cytomapper::normalize(cur_images, separateImages = TRUE)
cur_images <- cytomapper::normalize(cur_images, inputRange = c(0, 0.2))

grid::current.viewport()
plot1 <- plotPixels(cur_images,
           mask = masks[c("patient2")],
           img_id = "sample_id",
           missing_colour = "white",
           colour_by = c("CD3", "CD20", "CD45", "aSMA", "DAPI"),
           colour = list(CD3 = c("black", "yellow"),
                         CD20 = c("black", "red"),
                         CD45 = c("black", "green"),
                         aSMA = c("black", "cyan"),
                         DAPI = c("black", "blue")),
           legend = list(colour_by.title.cex = 0.7,
                         colour_by.labels.cex = 0.7))
plot1

#the mean marker expression per image to identify images with outlying marker expression
library(scuttle)

image_mean <- aggregateAcrossCells(spe, 
                                   ids = spe$sample_id, 
                                   statistics="mean",
                                   use.assay.type = "counts")
assay(image_mean, "exprs") <- asinh(counts(image_mean))

dittoHeatmap(image_mean, genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", cluster_cols = TRUE, scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = c("patient_id"),
             annotation_colors = list(
             indication = metadata(spe)$color_vectors$indication,
             patient_id = metadata(spe)$color_vectors$patient_id),
             show_colnames = TRUE)
             
#Cell-level quality control
library(mclust)

set.seed(220224)
mat <- sapply(seq_len(nrow(spe)), function(x){
    cur_exprs <- assay(spe, "exprs")[x,]
    cur_counts <- assay(spe, "counts")[x,]
    
    cur_model <- Mclust(cur_exprs, G = 2)
    mean1 <- mean(cur_counts[cur_model$classification == 1])
    mean2 <- mean(cur_counts[cur_model$classification == 2])
    
    signal <- ifelse(mean1 > mean2, mean1, mean2)
    noise <- ifelse(mean1 > mean2, mean2, mean1)
    
    return(c(snr = signal/noise, ps = signal))
})
    
cur_snr <- t(mat) %>% as.data.frame() %>% 
        mutate(marker = rownames(spe))

cur_snr %>% ggplot() +
    geom_point(aes(log2(ps), log2(snr))) +
    geom_label_repel(aes(log2(ps), log2(snr), label = marker)) +
    theme_minimal(base_size = 15) + ylab("Signal-to-noise ratio [log2]") +
    xlab("Signal intensity [log2]")
    
#distributions of cell size across the individual images
dittoPlot(spe, var = "area", 
          group.by = "sample_id", 
          plots = "boxplot") +
        ylab("Cell area") + xlab("")
        
summary(spe$area)

#remove very small cells
sum(spe$area < 5)

spe <- spe[,spe$area >= 5]

#absolute measure of cell density

cell_density <- colData(spe) %>%
    as.data.frame() %>%
    group_by(sample_id) %>%
    summarize(cell_count = n(),
           no_pixels = mean(width_px) * mean(height_px)) %>%
    mutate(cells_per_mm2 = cell_count/(no_pixels/1000000))

ggplot(cell_density) +
    geom_point(aes(reorder(sample_id,cells_per_mm2), cells_per_mm2)) + 
    theme_minimal(base_size = 15) + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8)) +
    ylab("Cells per mm2") + xlab("")
    
#Observing potential staining differences
multi_dittoPlot(spe, vars = rownames(spe)[rowData(spe)$use_channel],
               group.by = "patient_id", plots = "ridgeplot", 
               assay = "exprs", 
               color.panel = metadata(spe)$color_vectors$patient_id)
               
#project cells from a high-dimensional (40) down to a low-dimensional (2) space
library(scater)

set.seed(220225)
spe <- runUMAP(spe, subset_row = rowData(spe)$use_channel, exprs_values = "exprs") 
spe <- runTSNE(spe, subset_row = rowData(spe)$use_channel, exprs_values = "exprs") 

reducedDims(spe)

head(reducedDim(spe, "UMAP"))

#Visualization of the low-dimensional embedding facilitates assessment of potential “batch effects”
library(patchwork)

# visualize patient id 
p1 <- dittoDimPlot(spe, var = "patient_id", reduction.use = "UMAP", size = 0.2) + 
    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +
    ggtitle("Patient ID on UMAP")
p2 <- dittoDimPlot(spe, var = "patient_id", reduction.use = "TSNE", size = 0.2) + 
    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +
    ggtitle("Patient ID on TSNE")

(p1 + p2)

# visualize marker expression
p1 <- dittoDimPlot(spe, var = "CK", reduction.use = "UMAP", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "CK") +
    ggtitle("Ck expression on UMAP")
p2 <- dittoDimPlot(spe, var = "CD45", reduction.use = "UMAP", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "CD45") +
    ggtitle("CD45 expression on UMAP")
p3 <- dittoDimPlot(spe, var = "CK", reduction.use = "TSNE", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "CK") +
    ggtitle("CK expression on TSNE")
p4 <- dittoDimPlot(spe, var = "CD45", reduction.use = "TSNE", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "CD45") +
    ggtitle("CD45 expression on TSNE")

(p1 + p2) / (p3 + p4)

saveRDS(spe, "/media/Lena/steinbock_all/spe.rds")

#---------------------------------------------------------

#Batch effect correction
spe <- readRDS("/media/Lena/steinbock_all/spe.rds")

#-------------------
#harmony correction

library(batchelor)
library(scater)
library(cowplot)
library(dittoSeq)
library(viridis)

#visualize the expression of selected markers across all cells before and after batch correction
markers <- c("aSMA", "CD45", "CD20", "CD3", "Foxp3", "CD8", "CK", "s100", "Ki-67")

library(harmony)
library(BiocSingular)

spe <- runPCA(spe, 
              subset_row = rowData(spe)$use_channel, 
              exprs_values = "exprs", 
              ncomponents = 30,
              BSPARAM = ExactParam())

set.seed(230616)
out <- RunHarmony(spe, group.by.vars = "patient_id")

# Check that order of cells is the same
stopifnot(all.equal(colnames(spe), colnames(out)))

reducedDim(spe, "harmony") <- reducedDim(out, "HARMONY")

set.seed(220228)
spe <- runUMAP(spe, dimred = "harmony", name = "UMAP_harmony") 

# visualize patient id after correction
p2 <- dittoDimPlot(spe, var = "patient_id", 
                   reduction.use = "UMAP_harmony", size = 0.2) + 
    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +
    ggtitle("Patient ID on UMAP after correction")

plot_grid(p2)


# After correction
plot_list <- multi_dittoDimPlot(spe, var = markers, reduction.use = "UMAP_harmony", 
                   assay = "exprs", size = 0.2, list.out = TRUE) 
plot_list <- lapply(plot_list, function(x) x + scale_color_viridis())
plot_grid(plotlist = plot_list)

saveRDS(spe, "/media/Lena/steinbock_all/spe.rds")

#-------------------------------------------------------
#Cell phenotyping

#Rphenograph

library(SpatialExperiment)
spe <- readRDS("/media/Lena/steinbock_all/spe.rds")

# Sample cells
set.seed(220619)
cur_cells <- sample(seq_len(ncol(spe)), 2000)

library(Rphenograph)
library(igraph)
library(dittoSeq)
library(viridis)
                              
#use the integrated cells as some clusters only contain cells of a single patient
mat <- reducedDim(spe, "harmony")

set.seed(230619)
out <- Rphenograph(mat, k = 45)

clusters <- factor(membership(out[[2]]))

spe$pg_clusters_corrected <- clusters

dittoDimPlot(spe, var = "pg_clusters_corrected", 
             reduction.use = "UMAP_harmony", size = 0.2,
             do.label = TRUE) +
    ggtitle("Phenograph clusters on UMAP, integrated cells")
    
dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = c("pg_clusters_corrected","patient_id"),
             annot.colors = c(dittoColors(1)[1:length(unique(spe$pg_clusters_corrected))],
                              metadata(spe)$color_vectors$patient_id))

library(bluster)
library(BiocParallel)
library(ggplot2)
library(scran)
library(CATALYST)
library(kohonen)
library(ConsensusClusterPlus)

#assign cell types to clusters

library(dplyr)
cluster_celltype <- recode(spe$pg_clusters_corrected,
                            "1" = "Treg",
                            "2" = "Tumor",
                            "3" = "Tumor",
                            "4" = "Tcyt",
                            "5" = "Thelp",
                            "6" = "Tumor",
                            "7" = "Tumor",
                            "8" = "Tumor",
                            "9" = "Stroma",
                            "10" = "MPtoDC",
                            "11" = "Tumor",
                            "12" = "Treg",
                            "13" = "Epithelial",
                            '14' = 'Bcell',
                            '15'= 'MPtoDC',
                            '16' = 'Stroma',
                            '17' = 'Stroma',
                            '18' = 'Stroma',
                            '19' = 'Stroma',
                            '20' = 'Stroma')

spe$cluster_celltype <- cluster_celltype

celltype <- setNames(c("#bb7ff3", 
"#F4AD31", 
"#BF0A3D", 
"#1C750C", 
"#f3a5d2", 
"#6471E2", 
"#4DB23B", 
"#F4800C"),

c("Treg", 
"Stroma", 
"Epithelial", 
"Tcyt", 
"Thelp", 
"Treg", 
"MPtoDC", 
"Bcell"))

metadata(spe)$color_vectors$celltype <- celltype

dittoDimPlot(spe, var = "cluster_celltype", 
             reduction.use = "UMAP_harmony", size = 0.2,
             do.label = TRUE) +
    ggtitle("Phenograph clusters on UMAP, integrated cells")
  
dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = c("cluster_celltype","patient_id"),
             annot.colors = c(dittoColors(1)[1:length(unique(cluster_celltype))],
                              metadata(spe)$color_vectors$patient_id))

saveRDS(spe, "/media/Lena/steinbock_all/spe.rds")

#----------------------------------------------------

#Single cell visualization
spe <- readRDS("/media/Lena/steinbock_all/spe.rds")

# Define cell phenotype markers 
type_markers <- c("CK", "CD45", "CD20", "CD3", "Foxp3", "CD31", "HLA-DR", 
                  "aSMA", 'CD68', "CD11c", 'CD8', 'CD4')

# Define cell state markers 
state_markers <- c("s100", "Ki-67", "PD-1", "Vimentin", "PD-L1", 
                   "IDO-1", 'CD16', 'CD38')

# Add to spe
rowData(spe)$marker_class <- ifelse(rownames(spe) %in% type_markers, "type",
                                    ifelse(rownames(spe) %in% state_markers, "state", 
                                    "other"))

#Cell-type level

library(dittoSeq)
library(scater)
library(patchwork)
library(cowplot)
library(viridis)

## UMAP colored by cell type and expression - dittoDimPlot
p1 <- dittoDimPlot(spe, 
                   var = "cluster_celltype", 
                   reduction.use = "UMAP_harmony", 
                   size = 0.2,
                   do.label = TRUE) +
  scale_color_manual(values = metadata(spe)$color_vectors$celltype) +
  theme(legend.title = element_blank()) +
  ggtitle("Cell types on UMAP, integrated cells")
  
p2 <- dittoDimPlot(spe, 
                   var = "CK", 
                   assay = "exprs",
                   reduction.use = "UMAP_harmony", 
                   size = 0.2, 
                   colors = viridis(100), 
                   do.label = TRUE) +
    scale_color_viridis()
  
p1 + p2

set.seed(220818)
cur_cells <- sample(seq_len(ncol(spe)), 4000)

# Heatmap visualization - DittoHeatmap
dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$marker_class == "type"],
             assay = "exprs", 
             cluster_cols = FALSE, 
             scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = c("cluster_celltype", "patient_id"),
             annotation_colors = list(patient_id = metadata(spe)$color_vectors$patient_id,
                                      celltype = metadata(spe)$color_vectors$cluster_celltype))

library(scuttle)

## aggregate by cell type
celltype_mean <- aggregateAcrossCells(as(spe, "SingleCellExperiment"),  
                     ids = spe$cluster_celltype, 
                     statistics = "mean",
                     use.assay.type = "exprs", 
                     subset.row = rownames(spe)[rowData(spe)$marker_class == "type"])

# No scaling
dittoHeatmap(celltype_mean,
             assay = "exprs", 
             cluster_cols = TRUE, 
             scale = "none",
             heatmap.colors = viridis(100),
             annot.by = c("cluster_celltype", "ncells"),
             annotation_colors = list(celltype = metadata(spe)$color_vectors$cluster_celltype,
                                      ncells = plasma(100)))
                                      
# Scaled to max
dittoHeatmap(celltype_mean,
             assay = "exprs", 
             cluster_cols = TRUE, 
             scaled.to.max = TRUE,
             heatmap.colors.max.scaled = inferno(100),
             annot.by = c("cluster_celltype", "ncells"),
             annotation_colors = list(celltype = metadata(spe)$color_vectors$cluster_celltype,
                                      ncells = plasma(100)))

# Z score scaled
dittoHeatmap(celltype_mean,
             assay = "exprs", 
             cluster_cols = TRUE, 
             annot.by = c("cluster_celltype", "ncells"),
             annotation_colors = list(celltype = metadata(spe)$color_vectors$cluster_celltype,
                                      ncells = plasma(100)))
                                      
#----------------------------
#Violin plot visualization

# Violin Plot - plotExpression
plotExpression(spe[,cur_cells], 
               features = rownames(spe)[rowData(spe)$marker_class == "type"],
               x = "cluster_celltype", 
               exprs_values = "exprs", 
               colour_by = "cluster_celltype") +
    theme(axis.text.x =  element_text(angle = 90))+
    scale_color_manual(values = celltype)
    
#Scatter plot visualization  
# Scatter plot
dittoScatterPlot(spe, 
                 x.var = "CD3", 
                 y.var="CD20", 
                 assay.x = "exprs", 
                 assay.y = "exprs", 
                 color.var = "cluster_celltype") +
    scale_color_manual(values = metadata(spe)$color_vectors$celltype) +
    ggtitle("Scatterplot for CD3/CD20 labelled by celltype")

# by sample_id - percentage
dittoBarPlot(spe, 
             var = "cluster_celltype", 
             group.by = "sample_id") +
    scale_fill_manual(values = metadata(spe)$color_vectors$celltype)

# by patient_id - count
dittoBarPlot(spe, 
             scale = "count",
             var = "cluster_celltype", 
             group.by = "patient_id") +
    scale_fill_manual(values = metadata(spe)$color_vectors$celltype)
    
#CATALYST-based visualization    
library(CATALYST)

# Save SPE in CATALYST-compatible object with renamed colData entries and 
# new metadata information
spe_cat <- spe 

spe_cat$sample_id <- factor(spe$sample_id)
spe_cat$cluster_id <- factor(spe$cluster_celltype)

# Add celltype information to metadata
metadata(spe_cat)$cluster_codes <- data.frame(celltype = factor(spe_cat$cluster_celltype))

#Pseudobulk-level MDS plot
# MDS pseudobulk by cell type
pbMDS(spe_cat, 
      by = "cluster_id", 
      features = rownames(spe_cat)[rowData(spe_cat)$marker_class == "type"], 
      label_by = "cluster_id", 
      k = "celltype") +
  scale_color_manual(values = metadata(spe_cat)$color_vectors$celltype)

#Reduced dimension plot on CLR of proportions
# CLR on cluster proportions across samples
clrDR(spe_cat, 
      dr = "PCA", 
      by = "cluster_id", 
      k = "celltype", 
      label_by = "cluster_id", 
      arrow_col = "sample_id", 
      point_pal = metadata(spe_cat)$color_vectors$celltype) 

#----------
#Sample-level
# Heatmap visualization - DittoHeatmap
dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$marker_class == "type"],
             assay = "exprs", 
             order.by = c("patient_id"),
             cluster_cols = FALSE, 
             scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = c("cluster_celltype", "patient_id"),
             annotation_colors = list(celltype = metadata(spe)$color_vectors$celltype,
                                      patient_id = metadata(spe)$color_vectors$patient_id))
                                      
#                                      

# mean expression by patient_id
patient_mean <- aggregateAcrossCells(as(spe, "SingleCellExperiment"),  
                     ids = spe$patient_id, 
                     statistics = "mean",
                     use.assay.type = "exprs", 
                     subset.row = rownames(spe)[rowData(spe)$marker_class == "type"])

# No scaling
dittoHeatmap(patient_mean,
             assay = "exprs", 
             cluster_cols = TRUE, 
             scale = "none",
             heatmap.colors = viridis(100),
             annot.by = c("patient_id", "ncells"),
             annotation_colors = list(patient_id = metadata(spe)$color_vectors$patient_id,
                                      ncells = plasma(100)))

#Barplot visualization
dittoBarPlot(spe, 
             var = "patient_id", 
             group.by = "cluster_celltype") +
    scale_fill_manual(values = metadata(spe)$color_vectors$patient_id)

#----------------------------
#CATALYST-based visualization
# MDS pseudobulk by sample_id 
pbMDS(spe_cat, 
      by = "sample_id", 
      color_by = "sample_id", 
      features = rownames(spe_cat)[rowData(spe_cat)$marker_class == "type"]) +
  scale_color_manual(values = metadata(spe_cat)$color_vectors$patient_id)
  
# CLR on sample proportions across clusters
clrDR(spe_cat, 
      dr = "PCA", 
      by = "sample_id", 
      point_col = "sample_id",
      k = "celltype", 
      point_pal = metadata(spe_cat)$color_vectors$sample_id) +
  scale_color_manual(values = metadata(spe_cat)$color_vectors$celltype)

----------------------------------
# Publication-ready ComplexHeatmap

library(ComplexHeatmap)
library(circlize)
library(tidyverse)
set.seed(22)

### 1. Heatmap bodies ###

# Heatmap body color 
col_exprs <- colorRamp2(c(0,1,2,3,4), 
                        c("#440154FF","#3B518BFF","#20938CFF",
                          "#6ACD5AFF","#FDE725FF"))

# Create Heatmap objects
# By cell type markers
celltype_mean <- aggregateAcrossCells(as(spe, "SingleCellExperiment"),  
                     ids = spe$cluster_celltype, 
                     statistics = "mean",
                     use.assay.type = "exprs", 
                     subset.row = rownames(spe)[rowData(spe)$marker_class == "type"])

h_type <- Heatmap(t(assay(celltype_mean, "exprs")),
        column_title = "type_markers",
        col = viridis(100),
        name= "mean exprs",
        show_row_names = TRUE, 
        show_column_names = TRUE)

draw(h_type)
    
# By cell state markers
cellstate_mean <- aggregateAcrossCells(as(spe, "SingleCellExperiment"),  
                     ids = spe$cluster_celltype, 
                     statistics = "mean",
                     use.assay.type = "exprs", 
                     subset.row = rownames(spe)[rowData(spe)$marker_class == "state"])

h_state <- Heatmap(t(assay(cellstate_mean, "exprs")),
        column_title = "state_markers",
        col = viridis(100),
        name= "mean exprs",
        show_row_names = TRUE,
        show_column_names = TRUE)
        
h_state

### 2. Heatmap annotation ###

### 2.1  Metadata features

anno <- colData(celltype_mean) %>% as.data.frame %>% select(cluster_celltype, ncells)


# Number of contributing patients per celltype
cluster_PID <- colData(spe) %>% 
    as.data.frame() %>% 
    select(cluster_celltype, patient_id) %>% 
    group_by(cluster_celltype) %>% table() %>% 
    as.data.frame()

n_PID <- cluster_PID %>% 
    filter(Freq>0) %>% 
    group_by(cluster_celltype) %>% 
    count(name = "n_PID") %>% 
    column_to_rownames("cluster_celltype")

# Create HeatmapAnnotation objects
# Modify annotation names directly in HeatmapAnnotation objects
ha_anno <- HeatmapAnnotation(cluster_celltype = anno$cluster_celltype,
                            border = TRUE, 
                            gap = unit(1,"mm"),
                            col = list(celltype = metadata(spe)$color_vectors$celltype),
                            which = "row")
    
ha_meta <- HeatmapAnnotation(n_cells = anno_barplot(anno$ncells, width = unit(10, "mm")),
                            n_PID = anno_barplot(n_PID, width = unit(10, "mm")),
                            border = TRUE, 
                            annotation_name_rot = 90,
                            gap = unit(1,"mm"),
                            which = "row")

### 2.2 Spatial features

# Add number of neighbors to spe object (saved in colPair)
spe$n_neighbors <- countLnodeHits(colPair(spe, "neighborhood"))

# Select spatial features and average over celltypes
spatial <- colData(spe) %>% 
    as.data.frame() %>% 
    select(area, cluster_celltype, n_neighbors)

spatial <- spatial %>% 
    select(-cluster_celltype) %>% 
    aggregate(by = list(celltype = spatial$cluster_celltype), FUN = mean) %>% 
    column_to_rownames("celltype")

# Create HeatmapAnnotation object
ha_spatial <- HeatmapAnnotation(
    area = spatial$area,
    n_neighbors = spatial$n_neighbors,
    border = TRUE,
    gap = unit(1,"mm"),
    which = "row")

### 3. Plot rich heatmap ###

# Create HeatmapList object
h_list <- h_type +
    h_state +
    ha_anno +
    ha_spatial +
    ha_meta 

# Plot
draw(h_list)
  
save.image(file = "cytomapper_cleaned.RData")


load("cytomapper_cleaned.RData")

-------------------------------------------------------
#pheatmap example
library(pheatmap)

#red-violet color set
h_type1 <- ComplexHeatmap::pheatmap(t(assay(celltype_mean, "exprs")), main = "Type markers", 
name = "mean exprs", 
cluster_rows = FALSE,
color = colorRampPalette(c("navy", "white", "firebrick3"))(50))
    
h_type1

#white-blue color set
h_type2 <- ComplexHeatmap::pheatmap(t(assay(celltype_mean, "exprs")), main = "Type markers", 
name = "mean exprs", 
cluster_rows = FALSE,
  color = colorRampPalette(c("white", "seashell", "cadetblue1", "dodgerblue2", "dodgerblue4"))(50))

h_type2
    
# By cell state markers
#red-violet color set
h_state1 <- ComplexHeatmap::pheatmap(t(assay(cellstate_mean)), main = "State markers", 
name = "mean exprs",
    color = colorRampPalette(c("navy", "white", "firebrick3"))(50),
    scale = "row", clustering_distance_rows = "correlation")

h_state1

#white-blue color set
h_state2 <- ComplexHeatmap::pheatmap(
  t(assay(cellstate_mean)), 
  main = "State markers",
  name = "mean exprs",
  color = colorRampPalette(c("white", "seashell", "cadetblue1", "dodgerblue2", "dodgerblue4"))(50),
  scale = "row",
  clustering_distance_rows = "correlation"
)

h_state2

# Create HeatmapList object
#red-violet color set
h_list1 <- h_type1 +
    h_state1 +
    ha_anno +
    ha_spatial +
    ha_meta 

# Plot
draw(h_list1)

#white-blue color set
h_list2 <- h_type2 +
    h_state2 +
    ha_anno +
    ha_spatial +
    ha_meta 

# Plot
draw(h_list2)

#Image visualization

# Sample images
set.seed(220517)
cur_id <- sample(unique(spe$sample_id), 3)
cur_images <- images[names(images) %in% cur_id]
cur_masks <- masks[names(masks) %in% cur_id]

#Pixel visualization
plotPixels(cur_images, 
           colour_by = "CK",
           bcg = list(CK = c(0, 5, 1)))

plotPixels(cur_images, 
           colour_by = c("CD20", "CK", "CD8", "CD68", "aSMA", "CD11c"),
           bcg = list(CD68 = c(0, 5, 1),
                      CK = c(0, 5, 1),
                      CD20 = c(0, 8, 1),
                      CD8 = c(0, 8, 1),
                      CD11c = c(0, 8, 1),
                      aSMA = c(0, 4, 1)))
                      
--------------------------
#Image normalization

# 0 - 1 channel scaling across all images
norm_images <- cytomapper::normalize(cur_images)

# Clip channel at 0.2
norm_images <- cytomapper::normalize(norm_images, inputRange = c(0, 0.2))

plotPixels(norm_images, 
           colour_by = c("CD20", "CD11c", "CD8", "CD68", "CK", "aSMA"))

#Visualzing metadata
plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", 
          img_id = "sample_id",
          colour_by = "cluster_celltype")
          
plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", 
          img_id = "patient_id",
          colour_by = "cluster_celltype",
          colour = list(celltype = metadata(spe)$color_vectors$celltype))
          
#only one color
Bcell <- spe[,spe$cluster_celltype == "Bcell"]

plotCells(cur_masks,
          object = Bcell, 
          cell_id = "ObjectNumber", 
          img_id = "patient_id",
          colour_by = "cluster_celltype",
          colour = list(cluster_celltype = c(Bcell = "red")),
          missing_colour = "white")

#area of each cell
plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", 
          img_id = "sample_id",
          colour_by = "area")

-------------------------------          
#Visualizating expression

#visualizing single-cell metadata on segmentation masks
plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", 
          img_id = "sample_id",
          colour_by = "CD11c",
          exprs_values = "exprs")
          
#visualize the maximum number of allowed markers as composites on the segmentation masks
#check again at home!!!!!
plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", 
          img_id = "sample_id",
          colour_by = "cluster_celltype",
          colour = list(cluster_celltype = c(
            CD8 = c("black", "deeppink"),
            CD3 = c("black", "darkolivegreen1"),
            CD20 = c("black", "cornflowerblue")),
          exprs_values = "exprs")

          
plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", 
          img_id = "sample_id",
          colour_by = c("CD20", "CK", "aSMA", "CD68", "CD8", "CD11c"),
          exprs_values = "exprs")          
                        
--------------------------------         
#Outlining cells on images
#the combined visualization of pixel- and cell-level information at once

plotPixels(image = cur_images,
           mask = cur_masks,
           object = spe, 
           cell_id = "ObjectNumber", 
           img_id = "sample_id",
           colour_by = c("CD8", "CD3", "CD20"),
           outline_by = "cluster_celltype",
           bcg = list(CD8 = c(0, 5, 1),
                      CD3 = c(0, 5, 1),
                      CD20 = c(0, 5, 1)),
           display = "single",
           colour = list(celltype = metadata(spe)$color_vectors$celltype),
           thick = TRUE)

#selective visualization of cell outlines on composite images
Tcyt <- spe[,spe$cluster_celltype == "Tcyt"]

plotPixels(image = cur_images,
           mask = cur_masks,
           object = Tcyt, 
           cell_id = "ObjectNumber", 
           img_id = "patient_id",
           colour_by = c("CD4", "CD20"),
           outline_by = "cluster_celltype",
           bcg = list(CD4 = c(0, 5, 1),
                      CD20 = c(0, 5, 1)),
           colour = list(cluster_celltype = c(Tcyt = "white")),
           display = "single",
           thick = TRUE)

#Adjusting plot annotations
plotPixels(cur_images, 
           colour_by = c("CD20", "CK", "CD8", "CD11c", "CD31", "aSMA"),
           bcg = list(CD11c = c(0, 8, 1),
                      CK = c(0, 5, 1),
                      CD20 = c(0, 8, 1),
                      aSMA = c(0, 5, 1),
                      CD31 = c(0, 5, 1),
                      CD8 = c(0, 8, 1)),
           scale_bar = list(length = 100,
                            label = expression("100 " ~ mu * "m"),
                            cex = 0.7, 
                            lwidth = 10,
                            colour = "grey",
                            position = "bottomleft",
                            margin = c(5,5),
                            frame = 3),
           legend = list(colour_by.title.cex = 0.7,
                         margin = 10),
           margin = 40)

#Displaying individual images
plotCells(cur_masks,
          object = spe, 
          cell_id = "ObjectNumber", 
          img_id = "sample_id",
          colour_by = "cluster_celltype",
          colour = list(celltype = metadata(spe)$color_vectors$celltype),
          display = "single",
          legend = NULL)


save.image(file = "cytomapper_cleaned.RData")


load("cytomapper_cleaned.RData")


---------------------------------------------------
#Spatial analysis
library(SpatialExperiment)

# Spatial interaction graphs

spe <- buildSpatialGraph(spe, img_id = "sample_id", type = "knn", k = 20)
spe <- buildSpatialGraph(spe, img_id = "sample_id", type = "expansion", threshold = 20)
spe <- buildSpatialGraph(spe, img_id = "sample_id", type = "delaunay", max_dist = 20)

colPairNames(spe)


library(ggplot2)
library(viridis)

# steinbock interaction graph 
plotSpatial(spe[,spe$sample_id == "patient2"], 
            node_color_by = "cluster_celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "neighborhood", 
            nodes_first = FALSE, 
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$celltype) +
    ggtitle("steinbock interaction graph")


# knn interaction graph 
plotSpatial(spe[,spe$sample_id == "patient1"], 
            node_color_by = "cluster_celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "knn_interaction_graph", 
            nodes_first = FALSE,
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$celltype) +
    ggtitle("knn interaction graph")

plotSpatial(spe[,spe$sample_id == "patient1"], 
            node_color_by = "aSMA", 
            assay_type = "exprs",
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "expansion_interaction_graph", 
            nodes_first = FALSE, 
            node_size_by = "area", 
            directed = FALSE,
            edge_color_fix = "grey") + 
    scale_size_continuous(range = c(0.1, 2)) +
    ggtitle("aSMA expression")

plotSpatial(spe, 
            node_color_by = "cluster_celltype", 
            img_id = "sample_id", 
            node_size_fix = 0.5) + 
    scale_color_manual(values = metadata(spe)$color_vectors$celltype)

------------------------------------
#Spatial community analysis

set.seed(230621)
spe <- detectCommunity(spe, 
                       colPairName = "neighborhood", 
                       size_threshold = 20)
                       
plotSpatial(spe,
            img_id = "sample_id",
            node_color_by = "spatial_community",
            scales = "free")
            
#doesn't work properly, all in grey
plotSpatial(spe, 
            node_color_by = "spatial_community", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    theme(legend.position = "none") +
    ggtitle("Spatial tumor communities") +
    scale_color_manual(values = rev(colors()))

spe$tumor_stroma <- ifelse(spe$cluster_celltype == "Tumor", "Tumor", "Stroma")

library(BiocParallel)
spe <- detectCommunity(spe, 
                       colPairName = "neighborhood", 
                       size_threshold = 10,
                       group_by = "tumor_stroma",
                       BPPARAM = SerialParam(RNGseed = 220819))
                       
plotSpatial(spe[,spe$cluster_celltype == "Tumor"], 
            node_color_by = "spatial_community", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    theme(legend.position = "none") +
    ggtitle("Spatial tumor communities") +
    scale_color_manual(values = rev(colors()))

#separate tumor communities
plotSpatial(spe[,spe$celltype != "Tumor"], 
            node_color_by = "spatial_community", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    theme(legend.position = "none") +
    ggtitle("Spatial non-tumor communities") +
    scale_color_manual(values = rev(colors())) 
    
#non-tumor
plotSpatial(spe[,spe$cluster_celltype != "Tumor"], 
            node_color_by = "spatial_community", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    theme(legend.position = "none") +
    ggtitle("Spatial non-tumor communities") +
    scale_color_manual(values = rev(colors()))

#the fraction of cell types within each spatial stromal community is displayed
library(pheatmap)
library(viridis)

cur_spe <- spe[,spe$cluster_celltype != "Tumor"]

for_plot <- prop.table(table(cur_spe$spatial_community, 
                             cur_spe$cluster_celltype), 
                       margin = 1)

pheatmap(for_plot, 
         color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         show_rownames = FALSE, 
         scale = "column")    
         
save.image(file = "cytomapper_cleaned.RData")

saveRDS(spe, "/media/Lena/steinbock_all/spe.rds")

load("cytomapper_cleaned.RData")

----------------------------
#write csv
spatial_coords <- spe@int_colData@listData$spatialCoords
patient_id <- spe$patient_id
cluster_celltype <- spe$cluster_celltype

combined_data <- data.frame(
  SpatialCoords = spatial_coords,
  PatientID = patient_id,
  ClusterCellType = cluster_celltype
)

# Write to CSV
write.csv(combined_data, "combined_data.csv", row.names = FALSE)

patient1_data <- combined_data[combined_data$PatientID == "patient1", ]
patient2_data <- combined_data[combined_data$PatientID == "patient2", ]
patient3_data <- combined_data[combined_data$PatientID == "patient3", ]

#1_CellTypeLabel
#1_coordinates

write.csv(patient1_data, "patient1_data.csv", row.names = FALSE)
write.csv(patient2_data, "patient2_data.csv", row.names = FALSE)
write.csv(patient3_data, "patient3_data.csv", row.names = FALSE)
